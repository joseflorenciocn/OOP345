Script started on Fri 20 Apr 2018 10:27:56 PM EDT
jcoelho-neto@matrix:~/OOP345/Project/m3> whoami
jcoelho-neto
jcoelho-neto@matrix:~/OOP345/Project/m3> cat CustomerItem.cpp 
#include <iomanip> 
#include "CustomerItem.h"
#include "Item.h"


CustomerItem::CustomerItem(const std::string& customerItem)
{	
	if (!customerItem.empty()) 
	{
		name = customerItem;
		filled = false;
		code = 0;
	}

	else
	{
		name = char(0);
		filled = false;
		code = 0;
	}

}

bool CustomerItem::asksFor(const Item& item) const 
{ 
	if (name == item.getName())	return true;
	else return false;
}

bool CustomerItem::isFilled() const 
{ 
	return filled; 
}

void CustomerItem::fill(const unsigned int c) 
{
	code = c;
	filled = true;
}

void CustomerItem::clear() 
{
	code = 0;
	filled = false;
}

const std::string& CustomerItem::getName() const 
{ 
	return name; 
}

void CustomerItem::display(std::ostream& os) const 
{

	std::string init;

	if (filled)	init = " + [";
	else init = " - [";

	os << init;
	os << std::setw(CODE_WIDTH) << std::setfill('0');
	os << code << "] ";
	os << std::setfill(' ');
	os << name << std::endl;
	
}jcoelho-neto@matrix:~/OOP345/Project/m3> cat cu[K[KCustomerOrder.cpp 
#include <iomanip> 
#include <vector> 
#include "CustomerOrder.h"
#include "CustomerItem.h"
#include "Item.h"
#include "Utilities.h"

size_t CustomerOrder::field_width;

CustomerOrder::CustomerOrder(const std::string& record)
{
	nOrders = 0;
	order = nullptr;

	Utilities util;

	bool more = true;
	size_t next_pos = 0;
	std::string token;
	int token_qty = 0;

	std::vector<std::string> items;

	// while more tokens are available for extraction
	while (more)
	{
		try
		{
			token = util.nextToken(record, next_pos, more);

			if (token_qty == 0 && token !="Empty")
			{
				name = token;
				token_qty++;
			}

			else
			{
				if (token_qty == 1)
				{
					product = token;
					token_qty++;
				}

				else
				{
					if (more)
					{
						items.push_back(token);
						nOrders++;
						token_qty++;
					}
				}

			}
		}

		catch (const std::string& msg)
		{
			std::cout << msg << "<-- *** no token found before the delimiter ***" << std::endl;
		}

	}
	
	
	order = new CustomerItem[nOrders];

	for (size_t i=0; i<items.size(); i++) 
	{
		
		order[i] = items[i];
	}

	if (field_width < util.getFieldWidth()) field_width = util.getFieldWidth();

}

CustomerOrder::CustomerOrder(const CustomerOrder& other) 
{ 

	throw "*** Error: copy constructor not available ***"; 
}

CustomerOrder::CustomerOrder(CustomerOrder&& other) NOEXCEPT 
{
	order = nullptr;
	*this = std::move(other);
	
}

CustomerOrder&& CustomerOrder::operator=(CustomerOrder&& other) NOEXCEPT 
{
	if (this != &other) 
	{
		// deallocate memory
		delete[] order;

		// assign the values
		name = other.name;
		product = other.product;
		order = other.order;
		nOrders = other.nOrders;

		// reset the values
		other.name = char(0);
		other.product = char(0);
		other.order = nullptr;
		other.nOrders = 0;
	}
	return std::move(*this);
}

CustomerOrder::~CustomerOrder() 
{
	delete[] order;
	order = nullptr;
}

bool CustomerOrder::empty() const 
{	
	if (name.empty() && product.empty() && nOrders == 0) return true;
	else return false;
}

size_t CustomerOrder::noOrders() const 
{ 
	return nOrders; 
}

const std::string& CustomerOrder::operator[](unsigned int i) const 
{
	if (i >= nOrders) throw "index out of bounds";

	return order[i].getName();
}

void CustomerOrder::fill(Item& item) 
{
	for (size_t i = 0; i < nOrders; i++) {
		if (order[i].asksFor(item) && order[i].isFilled() == false) 
		{
			order[i].fill(item.getCode());
			item++;
		}
	}
}

void CustomerOrder::remove(Item& item) 
{
	for (size_t i = 0; i < nOrders; i++) 
	{
		if (order[i].asksFor(item) && order[i].isFilled()) 
		{
			order[i].clear();
		}
	}
}

void CustomerOrder::display(std::ostream& os) const 
{
	os << std::left << std::setw(field_width);
	os << name;
	os << std::right << std::setw(0);
	os << " : " << product << std::endl;

	// loop thourgh the CustomerItems object, fillind the ostream object
	for (size_t i = 0; i < nOrders; i++) 
	{
		order[i].display(os);
	}
}jcoelho-neto@matrix:~/OOP345/Project/m3> cat Item.cpp 
#include <iomanip> 
#include "Item.h"
#include "Utilities.h" 

size_t Item::field_width;


Item::Item(const std::string& record)
{	
	
	//description = "no detailed description";
	Utilities util;

	bool more = true;
	size_t next_pos = 0;
	std::string token;
	int token_qty = 0;

	// while more tokens are available for extraction
	while (more)
	{
		try
		{
			token = util.nextToken(record, next_pos, more);

			if (token_qty == 0 && token !="Empty")
			{
				name = token;
				token_qty++;
			}

			else
			{
				if (token_qty == 1)
				{
					filler = token;
					token_qty++;
				}

				else
				{
					if (token_qty == 2)
					{
						remover = token;
						token_qty++;
					}

					else
					{
						if (token_qty == 3)
						{
							//declare a placeholder to convert
							std::string::size_type size;
							// convert it to integer
							code = std::stoi(token, &size);
							token_qty++;
						}

						else
						{
							if (token_qty == 4)
							{
								if (!(token[0] == ' ') && !token.empty())
								{
								description = token;
								token_qty++;
								}
								
								else
								{
								description = "no detailed description";
								token_qty++;
								}
								
							}
						}
					}

				}

			}
		}

		catch (const std::string& msg)
		{
			std::cout << msg << "<-- *** no token found before the delimiter ***" << std::endl;
		}

	}

	if (field_width < util.getFieldWidth()) field_width = util.getFieldWidth();

}

bool Item::empty() const 
{ 
	return name.empty(); 
}

Item& Item::operator++(int c) 
{
  code++;
	return *this;
}

const std::string& Item::getName() const 
{ 
	return name; 
}

const std::string& Item::getFiller() const 
{ 
	return filler; 
}

const std::string& Item::getRemover() const 
{ 
	return remover; 
}

size_t Item::getCode() const 
{ 
	return code; 
}

void Item::display(std::ostream& os, bool full) const {
	os << std::left << std::setw(field_width) << std::setfill(' ');
	os << name << " [";
	os << std::right << std::setw(CODE_WIDTH) << std::setfill('0');
	os << code;
	os << std::setfill(' ') << "] ";

	// if the full flag is true, this function includes a complete description of the item
	if (full) 
	{
		os << "From ";
		os << std::left << std::setw(field_width);
		os << name << " To " << remover << std::endl;
		os << std::right << std::setw(field_width + CODE_WIDTH + 4);
		os << "  : " << description;
	}
	os << std::endl;
}jcoelho-neto@matrix:~/OOP345/Project/m3> cat Itwm[K[KemManager.cpp 
#include "ItemManager.h"

// display
// inserts into os descriptions of each item stored in the base class container.
// The bool parameter specifies whether a full description of the item should be inserted.
void ItemManager::display(std::ostream& os, bool fullDesc) const {
	// for range based loop
	for (auto& item : *this)
		item.display(os, fullDesc);
}jcoelho-neto@matrix:~/OOP345/Project/m3> cat main.cpp 
// Manager Milestone - Main Program
// Milestome_3.cpp
// Chris Szalwinski
// v1.0 - 16/11/2015
// v2.0 - 15/01/2016
#include <iostream>
#include <fstream>
#include <string>
#include <memory>
#include "Task.h"
#include "TaskManager.h"
#include "CustomerOrder.h"
#include "OrderManager.h"
#include "Item.h"
#include "ItemManager.h"
#include "Utilities.h"

template<typename M, typename T>
void loadFromFile(const char*, M&, std::ostream&);
template<>
void loadFromFile<TaskManager, Task>(const char*, TaskManager&, std::ostream&);

int main(int argc, char** argv) {
	// process command line arguments
	if (argc != 5) {
		std::cerr << "*** invalid number of arguments ***\n"
			<< "Usage: " << argv[0] << " tasks_file order_file item_file delimiter\n";
		exit(1);
	}
	std::cout << "Command Line Arguments\n----------------------\n";
	std::cout << "Task File Specified           = " << argv[1] << "\n";
	std::cout << "Customer Order File Specified = " << argv[2] << "\n";
	std::cout << "Item File Specified           = " << argv[3] << "\n";
	std::cout << "File Record Field Delimiter   = " << argv[4][0] << "\n\n";
	Utilities::setDelimiter(argv[4][0]);
	// end of command line processing

	// Load, accept, validate and display the Tasks
	//
	std::cout << "Building the Network of Tasks\n-----------------------------\n";
	TaskManager taskManager;
	loadFromFile<TaskManager, Task>(argv[1], taskManager, std::cerr);
	taskManager.display(std::cout);
	std::cout << "\nValidating the Set of Tasks\n---------------------------\n";
	taskManager.validate(std::cerr);
	std::cout << "\nList of Accepted Tasks\n----------------------\n";
	taskManager.display(std::cout);

	// Load, accept and display the Customer Orders
	//
	std::cout << "\n*** Load and Accept the Customer Orders ***\n";
	OrderManager orderManager;
	loadFromFile<OrderManager, CustomerOrder>(argv[2], orderManager, std::cerr);
	std::cout << "\nList of Accepted Customer Orders\n--------------------------------\n";
	orderManager.display(std::cout);

	// Load, accept and display the Items in Stock
	//
	std::cout << "\n*** Load and accept the Items in Stock ***\n";
	ItemManager itemManager;
	loadFromFile<ItemManager, Item>(argv[3], itemManager, std::cerr);
	std::cout << "\nList of In-Stock Items\n----------------------\n";
	itemManager.display(std::cout, true);

	// Validate the Items in the Customer Orders
	orderManager.validate(itemManager, std::cout);

	// Validate the Tasks in each Item in Stock
	taskManager.validate(itemManager, std::cerr);

	// Fill the Customer Orders with the Items in Stock
	std::cout << "\n*** Fill the Customer Orders ***\n";
	for (auto i = itemManager.begin(); i != itemManager.end(); i++) {
		for (auto s = orderManager.begin(); s != orderManager.end(); s++)
			s->fill(*i);
	}

	// Display the Processed Customer Orders
	std::cout << "\nList of Processed Customer Orders\n---------------------------------\n";
	orderManager.display(std::cout);

	// Terminate
	std::cout << "\nDone!\nPress Enter Key to Exit ... ";
	char c;
	std::cin.get(c);
}

template<typename M, typename T>
void loadFromFile(const char* fileName, M& manager, std::ostream& os) {
	std::ifstream file(fileName);
	if (!file) {
		os << "*** Cannot open file named " << fileName << " ***\n";
		exit(1);
	}
	while (file) {
		std::string record;
		std::getline(file, record);
		if (file) {
			try {
				std::unique_ptr<T> entry(new T(record));
				if (!entry->empty())
					manager.push_back(std::move(*entry));
			}
			catch (const std::string& msg) {
				os << msg << std::endl;
			}
		}
	}
}

template<>
void loadFromFile<TaskManager, Task>(const char* fileName, TaskManager& manager, std::ostream& os) {
	std::ifstream file(fileName);
	if (!file) {
		os << "*** Cannot open file named " << fileName << " ***\n";
		exit(1);
	}
	while (file) {
		std::string record;
		std::getline(file, record);
		if (file) {
			try {
				std::unique_ptr<Task> entry(new Task(record));
				if (!entry->getName().empty())
					manager.push_back(std::move(*entry));
			}
			catch (const std::string& msg) {
				os << msg << std::endl;
			}
		}
	}
}jcoelho-neto@matrix:~/OOP345/Project/m3> cat OrderManager.cpp
#include <algorithm> // find_if
#include "OrderManager.h"
#include "CustomerOrder.h"
#include "ItemManager.h"
#include "Item.h"

// extract
// moves a customerOrder from the back of the base class container
CustomerOrder&& OrderManager::extract() {
	return std::move(back());
}

// validate
// checks that the items requested in the customer orders are available,
// inserting a message into os for any item that is not available
void OrderManager::validate(const ItemManager& itemManager, std::ostream& os) {

	for (auto& order : *this) {
		for (size_t i = 0; i < order.noOrders(); i++) {
			auto it = std::find_if(itemManager.begin(), itemManager.end(), [&](const Item& item) { return order[i] == item.getName(); });
			if (it == itemManager.end()) {
				os << order[i] << " is unavailable\n";
			}
		}
	}
}

// display
// inserts into os descriptions of each customer order in the base class container
void OrderManager::display(std::ostream& os) const {
	for (auto& order : *this) {
		order.CustomerOrder::display(os);
	}
}jcoelho-neto@matrix:~/OOP345/Project/m3> cat Task.ca[Kpp 

// Milestone 1 - Task Manager
// Task.cpp
// Jose Florencio
// v1.0 - 19/03/2018

#include <string>
#include "Task.h"
#include "Utilities.h"

size_t Task::field_width = 0;

Task::Task(const std::string& record)
{
         
	this->slots="1";        
	this->pNextTask[0] = nullptr;
	this->pNextTask[1] = nullptr;

	Utilities util;

	bool more=true;
	size_t next_pos = 0;
	std::string token;
	int token_qty = 0;

	// while more tokens are available for extraction
	while (more)
	{
		try 
		{
			token = util.nextToken(record, next_pos, more);
			
			if (token_qty == 0)
			{
				name = token;
				token_qty++;
			}

			else
			{
				if (token_qty == 1)
				{
					slots = token;
					token_qty++;
				}

				else
				{
					if (token_qty == 2)
					{
						nextTask[passed] = token;
						token_qty++;
					}

					else
					{
						if (token_qty == 3)
						{
							nextTask[redirect] = token;
							token_qty++;
						}
					}

				}

			}
		}

		catch (const std::string& msg) 
		{
			std::cout << msg << "<-- *** no token found before the delimiter ***" << std::endl;
		}

	}

	if (field_width < util.getFieldWidth()) 
	{
		field_width = util.getFieldWidth();
	}

	
}

const std::string& Task::getName() const
{
	return this->name;
}

//Product slots in the token (converted from a string to an unsigned integer)
unsigned int Task::getSlots() const
{
	unsigned int val = atoi(slots.c_str()); 
	return val;

}

bool Task::validate(const Task& task) 
{
	bool valid = true;
	for (int i = 0; i < 2; i++) 
	{
		if (!nextTask[i].empty() && nextTask[i] == task.getName()) pNextTask[i] = &task;
		if (!nextTask[i].empty() && !pNextTask[i]) valid = false;
	}
	return valid;

}
const Task* Task::getNextTask(Quality quantity) const
{	
	if (!nextTask[quantity].empty() && !pNextTask[quantity])
	{
		throw std::string("*** Validate [" + nextTask[quantity] + "] @ [" + name + "] ***");
	}

	return pNextTask[quantity];
}

void Task::display(std::ostream& out) const
{

	out.setf(std::ios::left);
	out << "Task Name    : ";
	out.width(field_width + 2);
	out << "[" + name + "]" << " [" + slots + "]" << std::endl;

		if (!nextTask[passed].empty()) 
		{
			out << " Continue to : ";
			out.width(field_width + 2);
			out << "[" + nextTask[passed] + "]";

			if (!pNextTask[passed]) 
			{
				out << " *** to be validated ***";
			}
			out << std::endl;
		}

		if (!nextTask[redirect].empty())
		{
			out << " Redirect to : ";
			out.width(field_width + 2);
			out << "[" + nextTask[redirect] + "]";

			if (!pNextTask[redirect])
			{
				out << " *** to be validated ***";
			}
			out << std::endl;
		}



}

size_t Task::getFieldWidth()
{

	return field_width;

}

bool operator==(const Task& first, const Task& second) 
{ 
	if (first.getName() == second.getName()) return true;
	else return false;
}jcoelho-neto@matrix:~/OOP345/Project/m3> cat TaskManager.cpp
#include <algorithm> // find_if
#include <string>
#include "TaskManager.h"
#include "Task.h"
#include "ItemManager.h"
#include "Item.h"

// validate - one parameter
// validates each task against all of the other tasks in the base class container
void TaskManager::validate(std::ostream& os) {
	bool valid = true;

	// validates each task against all others
	for (auto& i : *this) {
		for (auto& j : *this) {
			if (&i != &j) {
				i.validate(j);
			}
		}
	}

	// checks if the task is valid
	for (auto& i : *this) {
		for (auto& j : *this) {
			if (&i != &j && !i.validate(j)) {
				valid = false;
			}
		}
	}

	// checks if all tasks were validated and displays message
	if (valid == false)
		os << "*** Not all tasks have been validated ***" << std::endl;
}

// validate - two parameter
// checks that the tasks assigned to handle each item managed by
// itemManager are tasks in the base class container
void TaskManager::validate(const ItemManager& itemManager, std::ostream& os) {

	// lambda expression
	auto compare = [&](const std::string taskName) {
		auto it = std::find_if(begin(), end(), [&](const Task& task) { return taskName == task.getName(); });
		if (it == end()) {
			os << taskName << " is unavailable" << std::endl;
		}
	};

	for (auto& item : itemManager) {
		compare(item.getFiller());
		compare(item.getRemover());
	}
}

// display
// inserts into the referenced ostream object descriptions of the tasks stored in tasks
void TaskManager::display(std::ostream& os) const {
	for (auto& tasks : *this)
		tasks.Task::display(os);
}jcoelho-neto@matrix:~/OOP345/Project/m3> cat Utilities.cpp
// Milestone 1 - Task Manager
// Utilities.cpp
// Jose Florencio
// v1.0 - 19/03/2018

#include "Utilities.h"
#include <string>
#include <iostream>
#include <fstream>

char Utilities::delimiter = '|';
std::ofstream Utilities::logFile;

Utilities::Utilities()
{

	field_width = 1;

}

//Not used in the program
/*
void Utilities::setFieldWidth(size_t fw)
{



}
*/


size_t Utilities::getFieldWidth() const
{

	return this->field_width;

}


const std::string Utilities::nextToken(const std::string& str, size_t& next_pos, bool& more)
{
	
	int del_qty = 0;
	int token_qty;


	std::string token;

	for (size_t i = next_pos; i < str.length(); i++)
	{
		if (str[i] == delimiter)
		{
			del_qty++;
		}

	}
		
	
	if (del_qty == 0 && next_pos == 0)
	{
		
		more = 0;
		token = "Empty";
		
	}
	
	else 
	{
		token_qty = (del_qty + 1);
	
		std::string* word_tmp = new std::string[token_qty];
		int* position = new int[token_qty];
		int flag = 0;
		position[0] = 0;

		for (size_t j = next_pos; j < str.length(); j++)
		{
			if (str[j] == delimiter || j==(str.length()-1))
			{
				position[flag] = j;		
			}

			if (str[j] == delimiter) flag++;

			else word_tmp[flag] = word_tmp[flag] + str[j];
		}
		
		token = word_tmp[0];

		//Code to trim the whitespaces
		if (token.length() > 1) 
		{
			unsigned fPos = token.find_first_not_of(" \a\b\f\n\r\t\v");
			unsigned lPos = token.find_last_not_of(" \a\b\f\n\r\t\v");
			if (fPos != std::string::npos)
				token = std::string(token, fPos, lPos - fPos + 1);
		}
		
	
		if (position[0] == 0 || (token_qty == 1 && token[0] ==' '))
		{
			next_pos = str.length();
			more = false;
		}

		else
		{		
			next_pos = (position[0] + 1);
			more = true;
		}

		delete[] word_tmp;
		delete[] position;


		if (field_width < token.length())
		{
			field_width = token.length();
		}

	
		if (str[0] == delimiter || (del_qty !=0 && token[0] ==' '))
		{
			
			more = 0;
		
		//Code to save the record from the task and pass as an throw exception
		//I made this code because i have a lot of problemns 
		//in the linux compilation that cant concatenate the strings
		/////////////////////////////////////////////////////////////
		std::string record;
		for (size_t i=0; i<(str.length()-1); i++)
		{
		record += str[i];
		}
		///////////////////////////////////////////////////////////////
		//If you are using visual studio environment comment this code above
		// and remove the comment before the throw execution
		
		
		//std::string record = str;
		throw std::string(record);
		}
		
	}
	

	return token;

}

void Utilities::setDelimiter(const char del)
{
	delimiter = del;
}

void Utilities::setLogFile(const char* logfile)
{
	std::ofstream file;
	file.open(logfile);
}

std::ofstream& Utilities::getLogFile()
{

	return logFile;

}
jcoelho-neto@matrix:~/OOP345/Project/m3> g++cat Utilities.cppTaskManager.cpp[6P.cpp OrderManager.cpp[7Pmain.cpp [7@ItemManager[C[C[C[C[C[7P[C[C[C[C[C[9@CustomerOrder[C[C[C[C[C[1PItem[C[C[C[C[Cwhoami[K7 grade.txt p[1@n[C[C[C[C[C[C[C[Csimpl[C[C[C[C[C[C[C[10Pcd w7..w8 Description.txt Prices.txtcd w8[K..w9 w10_text.dat encoded.dat %cd w9[K..w8 Description.txt Badprices.txt[3PPrices.txtBadprices.txtPrices.txt[3PPrices.txtcd w8[K..w8 Description.txt Prices.txt[16P7 grade.txt p[1@simpl[C[C[C[C[C[C[C[10Pcd w7..w6 products.txt cd w6[K[1P..w9 w10_text.dat encoded.dat %g++ -std=c++0x -o w9 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14Pw9 w10_text.dat encoded.dat %g++ -std=c++0x -o m3 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14Pw9 w10_text.dat encoded.dat %g++ -std=c++0x -o w9 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14Pw9 w10_text.dat encoded.dat %g++ -std=c++0x -o m3 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14Pw9 w10_text.dat encoded.dat %g++ -std=c++0x -o m3 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ccd w9[K..m3 clean_task.txt clean_cust.txt clean_item.txt "|"[2P|[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cg++ -std=c++0x -o m3 main.cpp CustomerItem.cpp CustomerOrder.cpp Item.cpp ItemManager.cpp OrderManager.cpp Task.cpp TaskManager.cpp Utilities.cpp
jcoelho-neto@matrix:~/OOP345/Project/m3> m3 robust_task.txt cu[K[Krobust_cust.txt robust_item.txt |[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cg++ -std=c++0x -o m3 main.cpp CustomerItem.cpp CustomerOrder.cpp Item.cpp ItemManager.cpp OrderManager.cpp Task.cpp TaskManager.cpp Utilities.cpp[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ccat Utilities.cpp[KTaskManager.cpp[6P.cpp OrderManager.cpp[7Pmain.cpp [7@ItemManager[C[C[C[C[C[7P[C[C[C[C[C[9@CustomerOrder[C[C[C[C[C[1PItem[C[C[C[C[Cwhoami[K7 grade.txt p[1@n[C[C[C[C[C[C[C[Csimpl[C[C[C[C[C[C[C[10Pcd w7..w8 Description.txt Prices.txtcd w8[K..w9 w10_text.dat encoded.dat %cd w9[K..w8 Description.txt Badprices.txt[3PPrices.txtBadprices.txtPrices.txt[3PPrices.txtcd w8[K..w8 Description.txt Prices.txt[16P7 grade.txt p[1@simpl[C[C[C[C[C[C[C[10Pcd w7..w6 products.txt cd w6[K[1P..w9 w10_text.dat encoded.dat %g++ -std=c++0x -o w9 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14Pw9 w10_text.dat encoded.dat %g++ -std=c++0x -o m3 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14Pw9 w10_text.dat encoded.dat %g++ -std=c++0x -o m3 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ccd w9[K..m3 clean_task.txt clean_cust.txt clean_item.txt "|"[2P|[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cg++ -std=c++0x -o m3 main.cpp CustomerItem.cpp CustomerOrder.cpp Item.cpp ItemManager.cpp OrderManager.cpp Task.cpp TaskManager.cpp Utilities.cpp[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ccd Project/m3/[K..[KProject/m3/g++ -std=c++0x -o m3 main.cpp CustomerItem.cpp CustomerOrder.cpp Item.cpp ItemManager.cpp OrderManager.cpp Task.cpp TaskManager.cpp Utilities.cpp[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[96Pm3 clean_task.txt clean_cust.txt clean_item.txt |[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Krobust_task.txt robust_cust.txt robust_item.txt |
> ^C
jcoelho-neto@matrix:~/OOP345/Project/m3> m3 robust_task.txt robust_cust.txt robust_item.txt |[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cg++ -std=c++0x -o m3 main.cpp CustomerItem.cpp CustomerOrder.cpp Item.cpp ItemManager.cpp OrderManager.cpp Task.cpp TaskManager.cpp Utilities.cpp[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ccat Utilities.cpp[KTaskManager.cpp[6P.cpp OrderManager.cpp[7Pmain.cpp [7@ItemManager[C[C[C[C[C[7P[C[C[C[C[C[9@CustomerOrder[C[C[C[C[C[1PItem[C[C[C[C[Cwhoami[K7 grade.txt p[1@n[C[C[C[C[C[C[C[Csimpl[C[C[C[C[C[C[C[10Pcd w7..w8 Description.txt Prices.txtcd w8[K..w9 w10_text.dat encoded.dat %cd w9[K..w8 Description.txt Badprices.txt[3PPrices.txtBadprices.txtPrices.txt[3PPrices.txtcd w8[K..w8 Description.txt Prices.txt[16P7 grade.txt p[1@simpl[C[C[C[C[C[C[C[10Pcd w7..w6 products.txt cd w6[K[1P..w9 w10_text.dat encoded.dat %g++ -std=c++0x -o w9 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14Pw9 w10_text.dat encoded.dat %g++ -std=c++0x -o m3 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[14Pw9 w10_text.dat encoded.dat %g++ -std=c++0x -o m3 w9.cpp SecureData.cpp [C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ccd w9[K..m3 clean_task.txt clean_cust.txt clean_item.txt "|"[2P|[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Cg++ -std=c++0x -o m3 main.cpp CustomerItem.cpp CustomerOrder.cpp Item.cpp ItemManager.cpp OrderManager.cpp Task.cpp TaskManager.cpp Utilities.cpp[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[Ccd Project/m3/[Kg++ -std=c++0x -o m3 main.cpp CustomerItem.cpp CustomerOrder.cpp Item.cpp ItemManager.cpp OrderManager.cpp Task.cpp TaskManager.cpp Utilities.cpp[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[96Pm3 clean_task.txt clean_cust.txt clean_item.txt |
> ^C
jcoelho-neto@matrix:~/OOP345/Project/m3> m3 clean_task.txt clean_cust.txt clean_item.txt |[K"|"
Command Line Arguments
----------------------
Task File Specified           = clean_task.txt
Customer Order File Specified = clean_cust.txt
Item File Specified           = clean_item.txt
File Record Field Delimiter   = |

Building the Network of Tasks
-----------------------------
Task Name    : [Power Supply]  [4]
 Continue to : [Motherboard]   *** to be validated ***
Task Name    : [Motherboard]   [3]
 Continue to : [CPU]           *** to be validated ***
 Redirect to : [Remove CPU]    *** to be validated ***
Task Name    : [Remove CPU]    [1]
 Continue to : [CPU]           *** to be validated ***
Task Name    : [CPU]           [5]
 Continue to : [Memory]        *** to be validated ***
 Redirect to : [Remove CPU]    *** to be validated ***
Task Name    : [Remove CPU]    [1]
 Continue to : [CPU]           *** to be validated ***
Task Name    : [Memory]        [4]
 Continue to : [SSD]           *** to be validated ***
 Redirect to : [Remove Memory] *** to be validated ***
Task Name    : [Remove Memory] [1]
 Continue to : [Memory]        *** to be validated ***
Task Name    : [SSD]           [4]
 Continue to : [GPU]           *** to be validated ***
 Redirect to : [Remove SSD]    *** to be validated ***
Task Name    : [Remove SSD]    [1]
 Continue to : [SSD]           *** to be validated ***
Task Name    : [GPU]           [3]
 Continue to : [Test]          *** to be validated ***
Task Name    : [Test]          [4]
 Continue to : [Approve]       *** to be validated ***
 Redirect to : [Repair]        *** to be validated ***
Task Name    : [Empty]         [1]
Task Name    : [Empty]         [1]

Validating the Set of Tasks
---------------------------
*** Not all tasks have been validated ***

List of Accepted Tasks
----------------------
Task Name    : [Power Supply]  [4]
 Continue to : [Motherboard]  
Task Name    : [Motherboard]   [3]
 Continue to : [CPU]          
 Redirect to : [Remove CPU]   
Task Name    : [Remove CPU]    [1]
 Continue to : [CPU]          
Task Name    : [CPU]           [5]
 Continue to : [Memory]       
 Redirect to : [Remove CPU]   
Task Name    : [Remove CPU]    [1]
 Continue to : [CPU]          
Task Name    : [Memory]        [4]
 Continue to : [SSD]          
 Redirect to : [Remove Memory]
Task Name    : [Remove Memory] [1]
 Continue to : [Memory]       
Task Name    : [SSD]           [4]
 Continue to : [GPU]          
 Redirect to : [Remove SSD]   
Task Name    : [Remove SSD]    [1]
 Continue to : [SSD]          
Task Name    : [GPU]           [3]
 Continue to : [Test]         
Task Name    : [Test]          [4]
 Continue to : [Approve]       *** to be validated ***
 Redirect to : [Repair]        *** to be validated ***
Task Name    : [Empty]         [1]
Task Name    : [Empty]         [1]

*** Load and Accept the Customer Orders ***

List of Accepted Customer Orders
--------------------------------
Fardad Soleimanloo  : Dell Precision 3600
 - [00000] CPU
 - [00000] Memory
 - [00000] Memory
 - [00000] 
Joseph Hughes       : HP Z230
 - [00000] CPU
 - [00000] Memory
Chris Szalwinski    : HP Z350
 - [00000] CPU
 - [00000] Memory
 - [00000] SSD
 - [00000] GPU
Elliott Coleshill   : HP Apollo 1000
 - [00000] CPU
 - [00000] MEMORY
 - [00000] Power Supply
 - [00000] GPU

*** Load and accept the Items in Stock ***

List of In-Stock Items
----------------------
CPU                     [00300] From CPU                     To Remove CPU
                              : Central Processing Unit
Memory                  [00400] From Memory                  To Remove Memory
                              : Samsung Memory Stick
GPU                     [00500] From GPU                     To Remove GPU
                              : Nvidia Geforce 750M
Power Supply            [00100] From Power Supply            To Remove Power Supply
                              : no detailed description
 is unavailable
SSD is unavailable
MEMORY is unavailable
Remove GPU is unavailable
Remove Power Supply is unavailable

*** Fill the Customer Orders ***

List of Processed Customer Orders
---------------------------------
Fardad Soleimanloo  : Dell Precision 3600
 + [00300] CPU
 + [00400] Memory
 + [00401] Memory
 - [00000] 
Joseph Hughes       : HP Z230
 + [00301] CPU
 + [00402] Memory
Chris Szalwinski    : HP Z350
 + [00302] CPU
 + [00403] Memory
 - [00000] SSD
 + [00500] GPU
Elliott Coleshill   : HP Apollo 1000
 + [00303] CPU
 - [00000] MEMORY
 + [00100] Power Supply
 + [00501] GPU

Done!
Press Enter Key to Exit ... 
jcoelho-neto@matrix:~/OOP345/Project/m3> m3 clean_task.txt clean_cust.txt clean_item.txt "|"[2P|[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[C[3@robust_task.txt robust_cust.txt robust[C[C[C[C[C[C[C[C[C[C[C[K"|"
Command Line Arguments
----------------------
Task File Specified           = robust_task.txt
Customer Order File Specified = robust_cust.txt
Item File Specified           = robust_item.txt
File Record Field Delimiter   = |

Building the Network of Tasks
-----------------------------
|<-- *** no token found before the delimiter ***
|Remove SSD|1|SSD<-- *** no token found before the delimiter ***
Task Name    : [Power Supply]  [4]
 Continue to : [Motherboard]   *** to be validated ***
Task Name    : [Motherboard]   [3]
 Continue to : [CPU]           *** to be validated ***
 Redirect to : [Remove CPU]    *** to be validated ***
Task Name    : [Remove CPU]    [1]
 Continue to : [CPU]           *** to be validated ***
Task Name    : [CPU]           [5]
 Continue to : [Memory]        *** to be validated ***
 Redirect to : [Remove CPU]    *** to be validated ***
Task Name    : [Remove CPU]    [1]
 Continue to : [CPU]           *** to be validated ***
Task Name    : [Memory]        [4]
 Continue to : [SSD]           *** to be validated ***
 Redirect to : [Remove Memory] *** to be validated ***
Task Name    : [Remove Memory] [1]
 Continue to : [Memory]        *** to be validated ***
Task Name    : [SSD]           [4]
 Continue to : [GPU]           *** to be validated ***
 Redirect to : [Remove SSD]    *** to be validated ***
Task Name    : [Remove SSD]    [1]
 Continue to : [SSD]           *** to be validated ***
Task Name    : [GPU]           [3]
 Continue to : [Test]          *** to be validated ***
Task Name    : [Test]          [4]
 Continue to : [Approve]       *** to be validated ***
 Redirect to : [Repair]        *** to be validated ***
Task Name    : [Empty]         [1]
Task Name    : [CPU]           [5]
 Continue to : [Memory]        *** to be validated ***
 Redirect to : [Remove CPU]    *** to be validated ***
Task Name    : [4]             [SSD]
 Continue to : [GPU]           *** to be validated ***
 Redirect to : [Remove SSD]    *** to be validated ***
Task Name    : [Empty]         [1]
Task Name    : [Empty]         [1]

Validating the Set of Tasks
---------------------------
*** Not all tasks have been validated ***

List of Accepted Tasks
----------------------
Task Name    : [Power Supply]  [4]
 Continue to : [Motherboard]  
Task Name    : [Motherboard]   [3]
 Continue to : [CPU]          
 Redirect to : [Remove CPU]   
Task Name    : [Remove CPU]    [1]
 Continue to : [CPU]          
Task Name    : [CPU]           [5]
 Continue to : [Memory]       
 Redirect to : [Remove CPU]   
Task Name    : [Remove CPU]    [1]
 Continue to : [CPU]          
Task Name    : [Memory]        [4]
 Continue to : [SSD]          
 Redirect to : [Remove Memory]
Task Name    : [Remove Memory] [1]
 Continue to : [Memory]       
Task Name    : [SSD]           [4]
 Continue to : [GPU]          
 Redirect to : [Remove SSD]   
Task Name    : [Remove SSD]    [1]
 Continue to : [SSD]          
Task Name    : [GPU]           [3]
 Continue to : [Test]         
Task Name    : [Test]          [4]
 Continue to : [Approve]       *** to be validated ***
 Redirect to : [Repair]        *** to be validated ***
Task Name    : [Empty]         [1]
Task Name    : [CPU]           [5]
 Continue to : [Memory]       
 Redirect to : [Remove CPU]   
Task Name    : [4]             [SSD]
 Continue to : [GPU]          
 Redirect to : [Remove SSD]   
Task Name    : [Empty]         [1]
Task Name    : [Empty]         [1]

*** Load and Accept the Customer Orders ***
||<-- *** no token found before the delimiter ***
| Peter McIntyre     <-- *** no token found before the delimiter ***

List of Accepted Customer Orders
--------------------------------
Fardad Soleimanloo  : Dell Precision 3600
 - [00000] CPU
 - [00000] Memory
 - [00000] Memory
Joseph Hughes       : HP Z230
 - [00000] CPU
 - [00000] Memory
Chris Szalwinski    : HP Z350
 - [00000] CPU
 - [00000] Memory
 - [00000] SSD
 - [00000] GPU
Elliott Coleshill   : HP Apollo 1000
 - [00000] CPU
 - [00000] MEMORY
 - [00000] Power Supply
 - [00000] GPU

*** Load and accept the Items in Stock ***
|<-- *** no token found before the delimiter ***
|Fan|Fan| Place fan       |900| CoolMasters R56||<-- *** no token found before the delimiter ***
 | | | | <-- *** no token found before the delimiter ***
||PCIe SSD<-- *** no token found before the delimiter ***

List of In-Stock Items
----------------------
CPU                     [00300] From CPU                     To Remove CPU
                              : Central Processing Unit
Memory                  [00400] From Memory                  To Remove Memory
                              : Samsung Memory Stick
GPU                     [00500] From GPU                     To Remove GPU
                              : Nvidia Geforce 750M
Power Supply            [00100] From Power Supply            To Remove Power Supply
                              : no detailed description
SSD is unavailable
MEMORY is unavailable
Remove GPU is unavailable
Remove Power Supply is unavailable

*** Fill the Customer Orders ***

List of Processed Customer Orders
---------------------------------
Fardad Soleimanloo  : Dell Precision 3600
 + [00300] CPU
 + [00400] Memory
 + [00401] Memory
Joseph Hughes       : HP Z230
 + [00301] CPU
 + [00402] Memory
Chris Szalwinski    : HP Z350
 + [00302] CPU
 + [00403] Memory
 - [00000] SSD
 + [00500] GPU
Elliott Coleshill   : HP Apollo 1000
 + [00303] CPU
 - [00000] MEMORY
 + [00100] Power Supply
 + [00501] GPU

Done!
Press Enter Key to Exit ... 
jcoelho-neto@matrix:~/OOP345/Project/m3> exit
exit

Script done on Fri 20 Apr 2018 10:35:45 PM EDT
